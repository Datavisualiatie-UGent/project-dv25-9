<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="generator" content="Observable Framework v1.13.2">
<title>Which genres do gamers play? | Who are gamers?</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_import/main-style.9a967542.css">
<link rel="preload" as="style" href="./_observablehq/stdlib/inputs.ea9fd553.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_import/main-style.9a967542.css">
<link rel="stylesheet" type="text/css" href="./_observablehq/stdlib/inputs.ea9fd553.css">
<link rel="modulepreload" href="./_observablehq/client.512864c7.js">
<link rel="modulepreload" href="./_observablehq/runtime.e080113b.js">
<link rel="modulepreload" href="./_observablehq/stdlib.82806664.js">
<link rel="modulepreload" href="./_npm/d3@7.9.0/e780feca.js">
<link rel="modulepreload" href="./_observablehq/stdlib/inputs.6ba3de0b.js">
<link rel="modulepreload" href="./_npm/@observablehq/plot@0.6.17/d761ef9b.js">
<link rel="modulepreload" href="./_npm/d3-dsv@3.0.1/9cffc2bd.js">
<link rel="modulepreload" href="./_npm/htl@0.3.1/72f4716c.js">
<link rel="modulepreload" href="./_npm/isoformat@0.2.1/18cbf477.js">
<link rel="modulepreload" href="./_npm/d3-array@3.2.4/e93ca09f.js">
<link rel="modulepreload" href="./_npm/d3-axis@3.0.0/0f2de24d.js">
<link rel="modulepreload" href="./_npm/d3-brush@3.0.0/65eb105b.js">
<link rel="modulepreload" href="./_npm/d3-chord@3.0.1/7ef8fb2e.js">
<link rel="modulepreload" href="./_npm/d3-color@3.1.0/aeb57b94.js">
<link rel="modulepreload" href="./_npm/d3-contour@4.0.2/1d2aed74.js">
<link rel="modulepreload" href="./_npm/d3-delaunay@6.0.4/5ced1d52.js">
<link rel="modulepreload" href="./_npm/d3-dispatch@3.0.1/9ba9c7f3.js">
<link rel="modulepreload" href="./_npm/d3-drag@3.0.0/4202580c.js">
<link rel="modulepreload" href="./_npm/d3-ease@3.0.1/cdd7e898.js">
<link rel="modulepreload" href="./_npm/d3-fetch@3.0.1/b4e2ad9a.js">
<link rel="modulepreload" href="./_npm/d3-force@3.0.0/5e804d15.js">
<link rel="modulepreload" href="./_npm/d3-format@3.1.0/86074ef6.js">
<link rel="modulepreload" href="./_npm/d3-geo@3.1.1/40599fb3.js">
<link rel="modulepreload" href="./_npm/d3-hierarchy@3.1.2/e49e792c.js">
<link rel="modulepreload" href="./_npm/d3-interpolate@3.0.1/8d1e5425.js">
<link rel="modulepreload" href="./_npm/d3-path@3.1.0/20d3f133.js">
<link rel="modulepreload" href="./_npm/d3-polygon@3.0.1/7553081f.js">
<link rel="modulepreload" href="./_npm/d3-quadtree@3.0.1/0dfd751c.js">
<link rel="modulepreload" href="./_npm/d3-random@3.0.1/3c90ee06.js">
<link rel="modulepreload" href="./_npm/d3-scale@4.0.2/843b6a76.js">
<link rel="modulepreload" href="./_npm/d3-scale-chromatic@3.1.0/ba24c2e7.js">
<link rel="modulepreload" href="./_npm/d3-selection@3.0.0/4d94e5b7.js">
<link rel="modulepreload" href="./_npm/d3-shape@3.2.0/6d3a6726.js">
<link rel="modulepreload" href="./_npm/d3-time@3.1.0/9f03c579.js">
<link rel="modulepreload" href="./_npm/d3-time-format@4.1.0/07c9626f.js">
<link rel="modulepreload" href="./_npm/d3-timer@3.0.1/b58a267d.js">
<link rel="modulepreload" href="./_npm/d3-transition@3.0.1/004da2ac.js">
<link rel="modulepreload" href="./_npm/d3-zoom@3.0.0/b5786b3f.js">
<link rel="modulepreload" href="./_npm/interval-tree-1d@1.0.4/53fe8176.js">
<link rel="modulepreload" href="./_npm/internmap@2.0.3/e08981d9.js">
<link rel="modulepreload" href="./_npm/delaunator@5.0.1/02d43215.js">
<link rel="modulepreload" href="./_npm/binary-search-bounds@2.0.5/cbf6ba23.js">
<link rel="modulepreload" href="./_npm/robust-predicates@3.0.2/aa00730b.js">
<link rel="icon" href="./_file/icon.7a94a462.png" type="image/png" sizes="32x32">
<script type="module">

import {define} from "./_observablehq/client.512864c7.js";
import {registerFile} from "./_observablehq/stdlib.82806664.js";

registerFile("./data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/playstation/games.csv", {"name":"./data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/playstation/games.csv","mimeType":"text/csv","path":"./_file/data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/playstation/games.35b3498f.csv","lastModified":1746537846882,"size":3386540});
registerFile("./data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/steam/games.csv", {"name":"./data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/steam/games.csv","mimeType":"text/csv","path":"./_file/data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/steam/games.1cb5a2bf.csv","lastModified":1746537852221,"size":17068220});
registerFile("./data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/xbox/games.csv", {"name":"./data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/xbox/games.csv","mimeType":"text/csv","path":"./_file/data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/xbox/games.0785ca99.csv","lastModified":1746537856060,"size":1284681});

define({id: "f802ff58", outputs: ["platformColors"], body: () => {
const platformColors = {
  "Playstation": "#8F00FF",
  "Steam":       "#FF8F00",
  "Xbox":        "#00FF8F",
  "All":         "#333333"
};
return {platformColors};
}});

define({id: "f0eb7225", inputs: ["FileAttachment"], outputs: ["gamesCSVPlaystation","gamesCSVSteam","gamesCSVXbox","parseRawGenreList","lowercaseLetters","uppercaseLetters","specialCharacters","allowedChars","specialRenamings","postProcessGenreName"], body: async (FileAttachment) => {
const gamesCSVPlaystation     = await FileAttachment(
    "./data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/playstation/games.csv"
).csv();
const gamesCSVSteam           = await FileAttachment(
    "./data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/steam/games.csv"
).csv();
const gamesCSVXbox            = await FileAttachment(
    "./data/datasets/artyomkruglov/gaming-profiles-2025-steam-playstation-xbox/versions/1/xbox/games.csv"
).csv();

function parseRawGenreList(raw) {
  try {
    return JSON.parse(raw.replace(/'/g, '"'));
  } catch {
    return [];
  }
}

const lowercaseLetters = Array.from('abcdefghijklmnopqrstuvwxyz');
const uppercaseLetters = Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
const specialCharacters = Array.from(' &/-+');
const allowedChars = [...lowercaseLetters, ...uppercaseLetters, ...specialCharacters];
const specialRenamings = [
      [["Party!"], "Party"],
      [["Education", "Educational"], "Educational & Trivia"],
      [["Music/Rhythm", "Music+"], "Music & Rhythm"],
      [["Action Horror", "Action-Adventure", "Action-RPG"], "Action"],
      [["Survival Horror"], "Survival"],
      [["Video Production"], "Video"],
      [["Fps"], "First Person Shooter"],
      [["Multi-Player Online Battle Arena"], "Mmo Battle"],
      [["FPS"], "First Person Shooter"],
    ]

function postProcessGenreName(genre) {
    // Only allow certain characters.
    genre = Array.from(genre).filter(char => allowedChars.includes(char)).join('');

    // Capitalize words
    let sentence = [];
    let previousSpecial = true;
    for (let char of Array.from(genre)) {
      if (specialCharacters.includes(char)) {
        previousSpecial = true;
        sentence.push(char);
        continue;
      }
      if (previousSpecial) {
        previousSpecial = false;
        sentence.push(char.toUpperCase());
        continue;
      }
      sentence.push(char.toLowerCase());
      
    }
    genre = sentence.join('');

    // Trim whitespace before and after.
    genre = genre.trim();

    // Some special renamings. 
    for (const [list, rename] of specialRenamings) {
      if (list.includes(genre)) return rename;
    }

    // Finally return the new genre.
    return genre;
}
return {gamesCSVPlaystation,gamesCSVSteam,gamesCSVXbox,parseRawGenreList,lowercaseLetters,uppercaseLetters,specialCharacters,allowedChars,specialRenamings,postProcessGenreName};
}});

define({id: "8b57c851", inputs: ["parseRawGenreList","postProcessGenreName","gamesCSVSteam","gamesCSVPlaystation","gamesCSVXbox"], outputs: ["buildMaps","mapsByPlatform","genresAboveMinGamesAmount"], body: (parseRawGenreList,postProcessGenreName,gamesCSVSteam,gamesCSVPlaystation,gamesCSVXbox) => {
function buildMaps(platformCSVs) {
  const genreGameCountsMap = new Map();   // For each genre how many games there are.
  const genreCoOccurrenceMap = new Map(); // For each genre G1 a map of genres G2. The amount of G1 games that are also G2 games.  
  const genreYearCountMap = new Map();    //
  const yearGamesMap = new Map()

  platformCSVs.forEach((platformCSV) => {
    platformCSV.forEach((game) => {
      const releaseDate = game.release_date;
      const releaseYear = new Date(releaseDate).getFullYear();

      const gameGenres = parseRawGenreList(game.genres).map(postProcessGenreName);
      gameGenres.forEach((G1) => {

        // build yearGamesMap (technically not really correct; but count for each genre the game has)
        yearGamesMap.set(releaseYear, (yearGamesMap.get(releaseYear) || 0) + 1);

        // build genreGameCountsMap
        genreGameCountsMap.set(G1, (genreGameCountsMap.get(G1) || 0) + 1);

        // build genreCoOccurrenceMap
        if (!genreCoOccurrenceMap.has(G1)) genreCoOccurrenceMap.set(G1, new Map());
        gameGenres.forEach((G2) => {
          if (!genreCoOccurrenceMap.has(G2)) genreCoOccurrenceMap.set(G2, new Map());

          genreCoOccurrenceMap.get(G1).set(G2, (genreCoOccurrenceMap.get(G1).get(G2) || 0) + 1);
          genreCoOccurrenceMap.get(G2).set(G1, (genreCoOccurrenceMap.get(G2).get(G1) || 0) + 1);
        
        });

        // build genreYearCountMap
        if (!genreYearCountMap.has(G1)) genreYearCountMap.set(G1, new Map());
        genreYearCountMap.get(G1).set(releaseYear, (genreYearCountMap.get(G1).get(releaseYear) || 0) + 1);

      });
    });
  });

  // for later processing in case of Correlation Matrix, see buildMatrix
  return [ genreGameCountsMap, genreCoOccurrenceMap, genreYearCountMap, yearGamesMap ];
}

const mapsByPlatform = {
  Steam:       buildMaps([gamesCSVSteam]),
  Playstation: buildMaps([gamesCSVPlaystation]),
  Xbox:        buildMaps([gamesCSVXbox]),
  All:         buildMaps([gamesCSVPlaystation, gamesCSVSteam, gamesCSVXbox])
};

function genresAboveMinGamesAmount(min, platform) {
  const [genreGameCountsMap, , , ] = mapsByPlatform[platform];
  return Array.from(genreGameCountsMap.entries())
    .filter(([, count]) => count >= min)
    .map(([genre, ]) => genre)
    .sort();
}
return {buildMaps,mapsByPlatform,genresAboveMinGamesAmount};
}});

define({id: "2135622d", outputs: ["buildMatrix"], body: () => {
function buildMatrix(genres, genreGameCountsMap, genreCoOccurrenceMap) {
  // initialize matrix
  const N = genres.length;
  const matrix = Array.from({ length: N }, () => Array(N).fill(0));

  // fill matrix
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      let element = genreCoOccurrenceMap.get(genres[i]).get(genres[j]) || 0;  // set the basic element value
      element = element / 2;                                                  // divide by 2 to because we counted every game double (G1 -> G2 & G2 -> G1)
      element = element / genreGameCountsMap.get(genres[i]);                  // normalize between [0, 1] by dividing with the total game count for that genre
      element = element * 100;                                                // transform to percentages
      matrix[i][j] = element;
    }
  }

  return matrix;
}
return {buildMatrix};
}});

define({id: "e1cf2434", inputs: ["Plot","platformColors","viewSelectedPlatform","d3"], outputs: ["heatmap"], body: (Plot,platformColors,viewSelectedPlatform,d3) => {
function heatmap(matrix, genres, { width } = {}) {

  // define the cells to be use in the heatmap as a list
  const cells = [];
  for (let i = 0; i < genres.length; i++) {
    for (let j = 0; j < genres.length; j++) {
      let value = matrix[i][j]; // can't use matrix[i][j] directly, or will break
      cells.push({
        x: genres[i],
        y: genres[j],
        value,
        fill: value
      });
    }
  }

  // the actual heatmap with cells as markpoints
  return Plot.plot({
    width,
    height: 500,
    marginBottom: 90, // manually determined so that genre names don't go out of bounds
    marginLeft: 110,  // manually determined so that genre names don't go out of bounds
    x: {
      domain: genres,
      tickSize: 0,
      tickRotate: -45
    },
    y: {
      domain: genres,
      tickSize: 0,
    },
    color: {
      legend: true,
      type: "sequential",
      range: ["white", platformColors[viewSelectedPlatform]],
      interpolate: "hsl",
      domain: [0, d3.max(cells, c => c.value)],
      label: "Overlap between genres (%)"
    },
    marks: [
      Plot.rect(cells, {
        x: "y",         // cell property "x"
        y: "x",         // cell property "y"
        fill: "fill",   // cell property "fill"
        stroke: "gray",
        title: c => `${c.x} games that are also ${c.y}: ${c.value.toFixed(1)}%`,
      })
    ]
  });
}
return {heatmap};
}});

define({id: "e9a0f4f7", inputs: ["Inputs","mapsByPlatform","view"], outputs: ["selectedPlatform","viewSelectedPlatform"], body: (Inputs,mapsByPlatform,view) => {
const selectedPlatform = Inputs.radio(
  Object.keys(mapsByPlatform), {
    label: "",
    multiple: false,
    value: "Steam", // default
  });
let viewSelectedPlatform = view(selectedPlatform);
return {selectedPlatform,viewSelectedPlatform};
}});

define({id: "afad1a0c", inputs: ["Inputs","view"], outputs: ["selectedMinGamesAmount","viewSelectedMinGamesAmount"], body: (Inputs,view) => {
const selectedMinGamesAmount = Inputs.number(
  [0, 1000], {
    label: "",
    step: 1, 
    value: 100, // default
  });
let viewSelectedMinGamesAmount = view(selectedMinGamesAmount);
return {selectedMinGamesAmount,viewSelectedMinGamesAmount};
}});

define({id: "ff584bbd", inputs: ["Inputs","genresAboveMinGamesAmount","viewSelectedMinGamesAmount","viewSelectedPlatform","view"], outputs: ["selectedGenres","viewSelectedGenres"], body: (Inputs,genresAboveMinGamesAmount,viewSelectedMinGamesAmount,viewSelectedPlatform,view) => {
const selectedGenres = Inputs.checkbox(genresAboveMinGamesAmount(viewSelectedMinGamesAmount, viewSelectedPlatform), {
    label: "",
    multiple: true,
    value: genresAboveMinGamesAmount(viewSelectedMinGamesAmount, viewSelectedPlatform), // default
});
let viewSelectedGenres = view(selectedGenres);
selectedGenres.classList.add("my‑checkbox‑group");
return {selectedGenres,viewSelectedGenres};
}});

define({id: "a5a70290", inputs: ["mapsByPlatform","genresAboveMinGamesAmount"], outputs: ["statCard"], body: (mapsByPlatform,genresAboveMinGamesAmount) => {
function statCard(selectedPlatform, selectedMinGamesAmount) {
  /* ALSO USED BY LINE CHART */
  const [genreGameCountsMap, , , yearGamesMap] = mapsByPlatform[selectedPlatform];

  // Total games
  const totalGames = Array.from(yearGamesMap.values()).reduce((total, count) => total + count, 0);

  // Selected games
  let selectedGamesCount = 0;
  genresAboveMinGamesAmount(selectedMinGamesAmount, selectedPlatform).forEach((genre) => {
    selectedGamesCount += genreGameCountsMap.get(genre) || 0;
  });

  // Calculate percentage
  const percentage = (selectedGamesCount / totalGames) * 100;

  const name = "Included games:";
  const number = percentage.toFixed(2)

  const container = document.createElement("div");
  container.className = "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4";
  
  const card = document.createElement("div");
  card.className = "card p-4";
  card.innerHTML = `
    <h2 style="font-size: 16px; margin-bottom: 8px;">${name}</h2>
    <span style="font-size: 28px; font-weight: bold;">${number.toLocaleString("en-US")}%</span>
  `;
  
  container.appendChild(card);
  return container;
}
return {statCard};
}});

define({id: "4b062bc0", inputs: ["mapsByPlatform","viewSelectedPlatform","buildMatrix","viewSelectedGenres","heatmap"], outputs: ["displayHeatmap"], body: (mapsByPlatform,viewSelectedPlatform,buildMatrix,viewSelectedGenres,heatmap) => {
function displayHeatmap(width) {
  const [ genreGameCountsMap, genreCoOccurrenceMap, , ] = mapsByPlatform[viewSelectedPlatform];
  const matrix = buildMatrix(viewSelectedGenres, genreGameCountsMap, genreCoOccurrenceMap);
  return heatmap(matrix, viewSelectedGenres, { width });
}
return {displayHeatmap};
}});

define({id: "820db7eb", mode: "inline", inputs: ["selectedPlatform","display"], body: async (selectedPlatform,display) => {
display(await(
selectedPlatform
))
}});

define({id: "e1d483e2", mode: "inline", inputs: ["selectedMinGamesAmount","display"], body: async (selectedMinGamesAmount,display) => {
display(await(
selectedMinGamesAmount
))
}});

define({id: "75c52282", mode: "inline", inputs: ["selectedGenres","display"], body: async (selectedGenres,display) => {
display(await(
selectedGenres
))
}});

define({id: "0560bb2f", mode: "inline", inputs: ["resize","displayHeatmap","display"], body: async (resize,displayHeatmap,display) => {
display(await(
resize((width) => displayHeatmap(width))
))
}});

define({id: "cbec55b2", mode: "inline", inputs: ["statCard","viewSelectedPlatform","viewSelectedMinGamesAmount","display"], body: async (statCard,viewSelectedPlatform,viewSelectedMinGamesAmount,display) => {
display(await(
statCard(viewSelectedPlatform, viewSelectedMinGamesAmount)
))
}});

define({id: "27fc3445", inputs: ["mapsByPlatform","d3","Plot"], outputs: ["genreYearCountMapAllConstant","_","allGenres","colors","colorScale","lineChart"], body: (mapsByPlatform,d3,Plot) => {
//import iwanthue from "iwanthue";
//const [ , , genreYearCountMapAllConstant, _ ] = mapsByPlatform[Object.keys(mapsByPlatform)[3]];
//const allGenres = Array.from(genreYearCountMapAllConstant.keys()).sort();
//const colorScale = d3.scaleOrdinal(allGenres, iwanthue(allGenres.length))

const [ , , genreYearCountMapAllConstant, _ ] = mapsByPlatform[Object.keys(mapsByPlatform)[3]];
const allGenres = Array.from(genreYearCountMapAllConstant.keys()).sort();
const colors = d3.quantize(d3.interpolateTurbo, allGenres.length);
const colorScale = d3.scaleOrdinal()
  .domain(allGenres)
  .range(colors);

function lineChart(genreYearCountMap, yearGamesMap, genres, years, relative, { width } = {}) {

  console.log(yearGamesMap)

  // do not use 2025 as it is not complete
  if (years[years.length-1] == 2025) {
    years = years.slice(0, -1); 
  }



  const points = [];
  genres.forEach((genre) => {
    years.forEach((year) => {
      let count = genreYearCountMap.get(genre).get(year) || 0;

      // only show if there are at least 20 games, otherwise too discontinuous
      if (count > 20) {

        if (relative) {
          count = count / yearGamesMap.get(year);
        }

        points.push({
          genre: genre,
          year: year,
          count: count
        })

      }
    })
  })

  return Plot.plot({
    width,
    height: 500,
    x: {
      grid: true,
      tickFormat: d3.format("d")
    },
    y: {
      grid: true
    },
    color: {
      type: "categorical",
      domain: genres,
      range: genres.map(g => colorScale(g)),
      legend: true
    },
    marks: [
      // The main lines
      Plot.line(points, {
        x: "year",
        y: "count",
        z: "genre",
        stroke: "genre",
      }),

      // tooltip
      Plot.line(points, {
        x: "year",
        y: "count",
        z: "genre",
        title: "genre",
        strokeWidth: 15,
        strokeOpacity: 0,
        hover: {
          strokeOpacity: 0.2
        }
      }),
      Plot.dot(points, {
        x: "year",
        y: "count",
        z: "genre",
        title: "genre",
        strokeOpacity: 0,
        strokeWidth: 20
      }),

      // Crosshair lines (axis-aligned rules + labels)
      //Plot.crosshair(points, {
      //  x: "year",
      //  y: "count",
      //  z: 100,
      //})
    ]
  });
}
return {genreYearCountMapAllConstant,_,allGenres,colors,colorScale,lineChart};
}});

define({id: "309744fc", inputs: ["Inputs","mapsByPlatform","view"], outputs: ["selectedPlatform2","viewSelectedPlatform2"], body: (Inputs,mapsByPlatform,view) => {
const selectedPlatform2 = Inputs.radio(
  Object.keys(mapsByPlatform), {
    label: "",
    multiple: false,
    value: "Steam", // default
  });
let viewSelectedPlatform2 = view(selectedPlatform2);
return {selectedPlatform2,viewSelectedPlatform2};
}});

define({id: "7eb79287", inputs: ["Inputs","view"], outputs: ["selectedMinGamesAmount2","viewSelectedMinGamesAmount2"], body: (Inputs,view) => {
const selectedMinGamesAmount2 = Inputs.number(
  [100, 1000], {
    label: "",
    step: 1, 
    value: 200, // default
  });
let viewSelectedMinGamesAmount2 = view(selectedMinGamesAmount2);
return {selectedMinGamesAmount2,viewSelectedMinGamesAmount2};
}});

define({id: "b270b388", inputs: ["Inputs","genresAboveMinGamesAmount","viewSelectedMinGamesAmount2","viewSelectedPlatform2","view"], outputs: ["selectedGenres2","viewSelectedGenres2"], body: (Inputs,genresAboveMinGamesAmount,viewSelectedMinGamesAmount2,viewSelectedPlatform2,view) => {
const selectedGenres2 = Inputs.checkbox(genresAboveMinGamesAmount(viewSelectedMinGamesAmount2, viewSelectedPlatform2), {
    label: "",
    multiple: true,
    value: ["Action", "Strategy", "Indie", "Free To Play"]
});
let viewSelectedGenres2 = view(selectedGenres2);
selectedGenres2.classList.add("my‑checkbox‑group");
return {selectedGenres2,viewSelectedGenres2};
}});

define({id: "9f8d59db", inputs: ["Inputs","view"], outputs: ["selectedRelative2","viewSelectedRelative2"], body: (Inputs,view) => {
const selectedRelative2 = Inputs.radio(["relative", "absolute"], {
    value: "relative", // default
});
let viewSelectedRelative2 = view(selectedRelative2);
return {selectedRelative2,viewSelectedRelative2};
}});

define({id: "5f0b569f", inputs: ["mapsByPlatform","viewSelectedPlatform2","viewSelectedRelative2","lineChart","viewSelectedGenres2"], outputs: ["displayLinechart"], body: (mapsByPlatform,viewSelectedPlatform2,viewSelectedRelative2,lineChart,viewSelectedGenres2) => {
function displayLinechart(width) {
  const [ , , genreYearCountMap, yearGamesMap ] = mapsByPlatform[viewSelectedPlatform2];
  
  let allYears = new Set();
  for (const subMap of genreYearCountMap.values()) {
    for (const year of subMap.keys()) {
      allYears.add(year);
    }
  }
  allYears = Array.from(allYears).sort();

  const relative = viewSelectedRelative2 == "relative";

  return lineChart(genreYearCountMap, yearGamesMap, viewSelectedGenres2, allYears, relative, { width });
}
return {displayLinechart};
}});

define({id: "9a916d1d", mode: "inline", inputs: ["selectedPlatform2","display"], body: async (selectedPlatform2,display) => {
display(await(
selectedPlatform2
))
}});

define({id: "ec78d68e", mode: "inline", inputs: ["selectedMinGamesAmount2","display"], body: async (selectedMinGamesAmount2,display) => {
display(await(
selectedMinGamesAmount2
))
}});

define({id: "3d1d0824", mode: "inline", inputs: ["selectedGenres2","display"], body: async (selectedGenres2,display) => {
display(await(
selectedGenres2
))
}});

define({id: "d87dd350", mode: "inline", inputs: ["selectedRelative2","display"], body: async (selectedRelative2,display) => {
display(await(
selectedRelative2
))
}});

define({id: "e1cefdca", mode: "inline", inputs: ["resize","displayLinechart","display"], body: async (resize,displayLinechart,display) => {
display(await(
resize((width) => displayLinechart(width))
))
}});

define({id: "9f39d2c8", mode: "inline", inputs: ["statCard","viewSelectedPlatform2","viewSelectedMinGamesAmount2","display"], body: async (statCard,viewSelectedPlatform2,viewSelectedMinGamesAmount2,display) => {
display(await(
statCard(viewSelectedPlatform2, viewSelectedMinGamesAmount2)
))
}});

</script>
</head>
<body>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link"><a href="./">Who are gamers?</a></li>
  </ol>
  <ol>
    <li class="observablehq-link"><a href="./platform-analysis">What do gamers play on?</a></li>
    <li class="observablehq-link"><a href="./country-analysis">Where are gamers?</a></li>
    <li class="observablehq-link"><a href="./review-analysis">What do gamers think?</a></li>
    <li class="observablehq-link observablehq-link-active"><a href="./genre-analyse">Which genres do gamers play?</a></li>
    <li class="observablehq-link"><a href="./profit-analysis">How do gamers spend?</a></li>
  </ol>
</nav>
<script>{const e=document.querySelector("#observablehq-sidebar"),o=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?o.checked=r==="true":o.indeterminate=!0;for(const t of document.querySelectorAll("#observablehq-sidebar summary")){const s=t.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${t.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<div id="observablehq-center">
<aside id="observablehq-toc" data-selector="h1:not(:first-of-type)[id], h2:first-child[id], :not(h1) + h2[id]">
<nav>
<div>Contents</div>
<ol>
<li class="observablehq-secondary-link"><a href="#correlation-between-genres">Correlation between genres</a></li>
<li class="observablehq-secondary-link"><a href="#genre-release-trend">Genre release trend</a></li>
</ol>
</nav>
</aside>
<main id="observablehq-main" class="observablehq">
<h1 id="which-genres-do-gamers-play" tabindex="-1"><a class="observablehq-header-anchor" href="#which-genres-do-gamers-play">Which genres do gamers play?</a></h1>
<br>
<div class="observablehq observablehq--block"><!--:f802ff58:--></div>
<!-- All the data & functions related to interpreting genres. -->
<div class="observablehq observablehq--block"><!--:f0eb7225:--></div>
<!-- Data transform functions -->
<div class="observablehq observablehq--block"><!--:8b57c851:--></div>
<!-- ============================================================================================================== -->
<!-- ============================================================================================================== -->
<!-- Correlation Matrix data postprocessing -->
<div class="observablehq observablehq--block"><!--:2135622d:--></div>
<!-- Correlation Matrix plot -->
<div class="observablehq observablehq--block"><!--:e1cf2434:--></div>
<!-- Correlation Matrix adaptive selectors -->
<div class="observablehq observablehq--block"><!--:e9a0f4f7:--></div>
<div class="observablehq observablehq--block"><!--:afad1a0c:--></div>
<div class="observablehq observablehq--block"><!--:ff584bbd:--></div>
<!-- Stat card -->
<div class="observablehq observablehq--block"><!--:a5a70290:--></div>
<!-- Correlation Matrix adaptive plot -->
<div class="observablehq observablehq--block"><!--:4b062bc0:--></div>
<!-- Correlation Matrix display -->
<h2 id="correlation-between-genres" tabindex="-1"><a class="observablehq-header-anchor" href="#correlation-between-genres">Correlation between genres</a></h2>
<div class="card">
  <div class="card">
    <observablehq-loading></observablehq-loading><!--:820db7eb:-->
    <div style="
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 0.85rem;
        padding-left: 5px;
      ">
      <span>Minimum amount of games:</span>
      <span style="width: 65px;">
        <observablehq-loading></observablehq-loading><!--:e1d483e2:-->
      </span>
    </div>
  </div>
  <div class="card">
    <observablehq-loading></observablehq-loading><!--:75c52282:-->
  </div>
</div>
<div class="card">
  <observablehq-loading></observablehq-loading><!--:0560bb2f:-->
  <observablehq-loading></observablehq-loading><!--:cbec55b2:-->
</div>
<p>Imagine stepping into the vast world of video games today; there's a genre for everyone. Some players crave the thrill of fast-paced action, while others prefer to take it slow, exploring rich worlds and intricate stories at their own pace. With so many genres out there, you might start to wonder: how are they all connected? Could certain genres be more closely tied together than others?</p>
<p>To explore this, look at the grid; on one side, we list genres as Genre Y, and across the top, we list them again as Genre X. In each square of this grid, the darkness of the shade tells us one thing: what percentage of games in genre Y also belong to genre X. The darker the square, the stronger the connection.</p>
<p>Take the relationship between Action and Violent games. If you look at it from the perspective of Action games, only 0.8% are also tagged as Violent. But flip it around; among Violent games, a massive 71.8% are also Action. What does that tell us? Likely, Action is a broader, more general category, while Violent is a more specific theme that fits within it.</p>
<p>Another clear example is the bond between Gore and Violent. An incredible 85.3% of Gore games are also marked as Violent, showing a near one-to-one relationship; games filled with gore are almost always violent in nature.</p>
<p>But the graph reveals more than just genre overlaps. One surprising insight is the sheer dominance of Indie games; about 75% of all games fall under this label. On the opposite end of the spectrum, Massively Multiplayer games are rarely Indie. That makes sense; these massive worlds demand far more resources, time, and funding to bring to life.</p>
<p>Then there’s another curious discovery: not all entries are really games at all. Some are actually utility applications, tools rather than entertainment. And when you look at the relationship; or rather, the lack of it: between Indie and Utility, a clear divide appears. Indie games stick firmly to the realm of play, while utilities remain in a world of function.</p>
<!-- ============================================================================================================== -->
<!-- ============================================================================================================== -->
<!-- Line Chart plot -->
<div class="observablehq observablehq--block"><!--:27fc3445:--></div>
<!-- Line Chart adaptive selectors -->
<div class="observablehq observablehq--block"><!--:309744fc:--></div>
<div class="observablehq observablehq--block"><!--:7eb79287:--></div>
<div class="observablehq observablehq--block"><!--:b270b388:--></div>
<div class="observablehq observablehq--block"><!--:9f8d59db:--></div>
<!-- Line Chart adaptive plot -->
<div class="observablehq observablehq--block"><!--:5f0b569f:--></div>
<!-- Line Chart display -->
<h2 id="genre-release-trend" tabindex="-1"><a class="observablehq-header-anchor" href="#genre-release-trend">Genre release trend</a></h2>
<div class="card">
  <div class="card">
    <observablehq-loading></observablehq-loading><!--:9a916d1d:-->
    <div style="
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 0.85rem;
        padding-left: 5px;
      ">
      <span>Minimum amount of games:</span>
      <span style="width: 65px;">
        <observablehq-loading></observablehq-loading><!--:ec78d68e:-->
      </span>
    </div>
  </div>
  <div class="card">
    <observablehq-loading></observablehq-loading><!--:3d1d0824:-->
  </div>
  <div class="card">
    <observablehq-loading></observablehq-loading><!--:d87dd350:-->
    <i style="color: grey;">
    (The relative option will normalize the a genre's game count to the total amount of games released that year.)
    </i>
  </div>
</div>
<div class="card">
  <observablehq-loading></observablehq-loading><!--:e1cefdca:-->
  <observablehq-loading></observablehq-loading><!--:9f39d2c8:-->
</div>
<p>Back in the early 2000s, Action and Strategy games reigned supreme. They were the go-to genres, dominating the gaming scene. But if you compare that to today, their popularity has declined. Why? One likely reason is the explosion in the number of games being released—along with that came a shift toward more specific and narrowly defined sub-genres. Instead of just Action, we now see tags like Shooter, Fighting, or Racing.</p>
<p>Another major shift came with the rise of the Indie label. In the early 2000s, the term was rarely used, if at all. But that changed quickly. As digital distribution platforms grew, so did the visibility and viability of small, independent developers. Now, Indie has become one of the most common and recognizable tags in gaming, as was also proven in earlier correlation graph.</p>
<p>As for the future of genre trends, it’s hard to say which ones will break out next. Most genres tend to remain relatively stable over time. However, there is one that’s slowly but surely gaining traction: Free To Play. With more developers experimenting with monetization models and players looking for accessible experiences, Free To Play continues its steady rise, thus hinting at where part of the industry might be heading next.</p>
</main>
<footer id="observablehq-footer">
<nav><a rel="prev" href="./review-analysis"><span>What do gamers think?</span></a><a rel="next" href="./profit-analysis"><span>How do gamers spend?</span></a></nav>
<div>Built with <a href="https://observablehq.com/" target="_blank" rel="noopener noreferrer">Observable</a> on <a title="2025-05-18T19:37:48">May 18, 2025</a>.</div>
</footer>
</div>
</body>
</html>
